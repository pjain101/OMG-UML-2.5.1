///////////////////////////////////////////////////////////
//  Property.cs
//  Implementation of the Class Property
//  Generated by Enterprise Architect
//  Created on:      31-янв-2019 22:00:10
//  Original author: Андрей
///////////////////////////////////////////////////////////

using System.Collections.Generic;
using UML.CommonStructure;
using UML.Deployments;
using UML.StructuredClassifiers;
using UML.Values;

namespace UML.Classification
{
    /// <summary>
    ///     A Property is a StructuralFeature. A Property related by ownedAttribute to a
    ///     Classifier (other than an association) represents an attribute and might also
    ///     represent an association end. It relates an instance of the Classifier to a
    ///     value or set of values of the type of the attribute. A Property related by
    ///     memberEnd to an Association represents an end of the Association. The type of
    ///     the Property is the type of the end of the Association. A Property has the
    ///     capability of being a DeploymentTarget in a Deployment relationship. This
    ///     enables modeling the deployment to hierarchical nodes that have Properties
    ///     functioning as internal parts.  Property specializes ParameterableElement to
    ///     specify that a Property can be exposed as a formal template parameter, and
    ///     provided as an actual parameter in a binding of a template.
    /// </summary>
    public interface Property : StructuralFeature, DeploymentTarget, ConnectableElement
    {
        /// <summary>
        ///     Specifies the kind of aggregation that applies to the Property.
        /// </summary>
        AggregationKind aggregation { get; set; }

        /// <summary>
        ///     If isComposite is true, the object containing the attribute is a container for
        ///     the object or value contained in the attribute. This is a derived value,
        ///     indicating whether the aggregation of the Property is composite or not.
        /// </summary>
        bool isComposite { get; set; }

        /// <summary>
        ///     Specifies whether the Property is derived, i.e., whether its value or values
        ///     can be computed from other information.
        /// </summary>
        bool isDerived { get; set; }

        /// <summary>
        ///     Specifies whether the property is derived as the union of all of the Properties
        ///     that are constrained to subset it.
        /// </summary>
        bool isDerivedUnion { get; set; }

        /// <summary>
        ///     True indicates this property can be used to uniquely identify an instance of
        ///     the containing Class.
        /// </summary>
        bool isID { get; set; }

        /// <summary>
        ///     The properties of which this Property is constrained to be a subset, if any.
        /// </summary>
        IEnumerable<Property> subsettedProperty { get; set; }

        /// <summary>
        ///     In the case where the Property is one end of a binary association this gives
        ///     the other end.
        /// </summary>
        Property opposite { get; set; }

        /// <summary>
        ///     A ValueSpecification that is evaluated to give a default value for the Property
        ///     when an instance of the owning Classifier is instantiated.
        /// </summary>
        ValueSpecification defaultValue { get; set; }

        /// <summary>
        ///     The properties that are redefined by this property, if any.
        /// </summary>
        IEnumerable<Property> redefinedProperty { get; set; }

        /// <summary>
        ///     An optional list of ordered qualifier attributes for the end.
        /// </summary>
        IEnumerable<Property> qualifier { get; set; }

        /// <summary>
        ///     The Association of which this Property is a member, if any.
        /// </summary>
        Association association { get; set; }

        /// <summary>
        ///     The query isAttribute() is true if the Property is defined as an attribute of
        ///     some Classifier.
        /// </summary>
        /// <param name="result"></param>
        bool isAttribute();

        /// <summary>
        ///     The query isCompatibleWith() determines if this Property is compatible with the
        ///     specified ParameterableElement. This Property is compatible with
        ///     ParameterableElement p if the kind of this Property is thesame as or a subtype
        ///     of the kind of p. Further, if p is a TypedElement, then the type of this
        ///     Property must be conformant with the type of p.
        /// </summary>
        /// <param name="result"></param>
        /// <param name="p"></param>
        bool isCompatibleWith(ParameterableElement p);

        /// <summary>
        /// The value of isComposite is true only if aggregation is composite.
        /// </summary>
        /// <param name="result"></param>
        //bool isComposite();

        /// <summary>
        ///     The query isConsistentWith() specifies, for any two Properties in a context in
        ///     which redefinition is possible, whether redefinition would be logically
        ///     consistent. A redefining Property is consistent with a redefined Property if
        ///     the type of the redefining Property conforms to the type of the redefined
        ///     Property, and the multiplicity of the redefining Property (if specified) is
        ///     contained in the multiplicity of the redefined Property.
        /// </summary>
        /// <param name="result"></param>
        /// <param name="redefiningElement"></param>
        bool isConsistentWith(RedefinableElement redefiningElement);

        /// <summary>
        ///     The query isNavigable() indicates whether it is possible to navigate across the
        ///     property.
        /// </summary>
        /// <param name="result"></param>
        bool isNavigable();

        /// <summary>
        /// If this property is a memberEnd of a binary association, then opposite gives
        /// the other end.
        /// </summary>
        /// <param name="result"></param>
        //Property opposite(Property result);

        /// <summary>
        ///     The query subsettingContext() gives the context for subsetting a Property. It
        ///     consists, in the case of an attribute, of the corresponding Classifier, and in
        ///     the case of an association end, all of the Classifiers at the other ends.
        /// </summary>
        /// <param name="result"></param>
        Type subsettingContext(Type result);
    }
} //end namespace Classification