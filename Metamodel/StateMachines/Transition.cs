///////////////////////////////////////////////////////////
//  Transition.cs
//  Implementation of the Class Transition
//  Generated by Enterprise Architect
//  Created on:      31-янв-2019 22:00:16
//  Original author: Андрей
///////////////////////////////////////////////////////////

using System.Collections.Generic;
using UML.Classification;
using UML.CommonBehavior;
using UML.CommonStructure;

namespace UML.StateMachines
{
    /// <summary>
    ///     A Transition represents an arc between exactly one source Vertex and exactly
    ///     one Target vertex (the source and targets may be the same Vertex). It may form
    ///     part of a compound transition, which takes the StateMachine from one steady
    ///     State configuration to another, representing the full response of the
    ///     StateMachine to an occurrence of an Event that triggered it.
    /// </summary>
    public interface Transition : RedefinableElement, Namespace
    {
        /// <summary>
        ///     Indicates the precise type of the Transition.
        /// </summary>
        TransitionKind kind { get; set; }

        /// <summary>
        ///     Specifies an optional behavior to be performed when the Transition fires.
        /// </summary>
        Behavior effect { get; set; }

        /// <summary>
        ///     References the Classifier in which context this element may be redefined.
        /// </summary>
        Classifier redefinitionContext { get; set; }

        /// <summary>
        ///     The Transition that is redefined by this Transition.
        /// </summary>
        Transition redefinedTransition { get; set; }

        /// <summary>
        ///     A guard is a Constraint that provides a fine-grained control over the firing of
        ///     the Transition. The guard is evaluated when an Event occurrence is dispatched
        ///     by the StateMachine. If the guard is true at that time, the Transition may be
        ///     enabled, otherwise, it is disabled. Guards should be pure expressions without
        ///     side effects. Guard expressions with side effects are ill formed.
        /// </summary>
        Constraint guard { get; set; }

        /// <summary>
        ///     Specifies the Triggers that may fire the transition.
        /// </summary>
        IEnumerable<Trigger> trigger { get; set; }

        /// <summary>
        ///     Designates the originating Vertex (State or Pseudostate) of the Transition.
        /// </summary>
        Vertex source { get; set; }

        /// <summary>
        ///     Designates the target Vertex that is reached when the Transition is taken.
        /// </summary>
        Vertex target { get; set; }

        /// <summary>
        /// The query containingStateMachine() returns the StateMachine that contains the
        /// Transition either directly or transitively.
        /// </summary>
        /// <param name="result"></param>
        //StateMachine containingStateMachine(StateMachine result){

        //	return null;
        //}

        /// <summary>
        /// The query isConsistentWith specifies that a redefining Transition is consistent
        /// with a redefined Transition provided that the source Vertex of the redefining
        /// Transition redefines the source Vertex of the redefined Transition.
        /// </summary>
        /// <param name="result"></param>
        /// <param name="redefiningElement"></param>
        //void isConsistentWith(result, RedefinableElement redefiningElement){

        //}

        /// <summary>
        /// The redefinition context of a Transition is the nearest containing StateMachine.
        /// 
        /// </summary>
        /// <param name="result"></param>
        //UML.Classification.Classifier redefinitionContext(Classifier result){

        //	return null;
        //}
    }
} //end namespace StateMachines