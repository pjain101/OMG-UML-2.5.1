///////////////////////////////////////////////////////////
//  State.cs
//  Implementation of the Class State
//  Generated by Enterprise Architect
//  Created on:      31-янв-2019 22:00:14
//  Original author: Андрей
///////////////////////////////////////////////////////////

using System.Collections.Generic;
using UML.CommonBehavior;
using UML.CommonStructure;

namespace UML.StateMachines
{
    /// <summary>
    ///     A State models a situation during which some (usually implicit) invariant
    ///     condition holds.
    /// </summary>
    public interface State : Vertex, Namespace
    {
        /// <summary>
        ///     A state with isComposite=true is said to be a composite State. A composite
        ///     State is a State that contains at least one Region.
        /// </summary>
        bool isComposite { get; set; }

        /// <summary>
        ///     A State with isOrthogonal=true is said to be an orthogonal composite State An
        ///     orthogonal composite State contains two or more Regions.
        /// </summary>
        bool isOrthogonal { get; set; }

        /// <summary>
        ///     A State with isSimple=true is said to be a simple State A simple State does not
        ///     have any Regions and it does not refer to any submachine StateMachine.
        /// </summary>
        bool isSimple { get; set; }

        /// <summary>
        ///     A State with isSubmachineState=true is said to be a submachine State Such a
        ///     State refers to another StateMachine(submachine).
        /// </summary>
        bool isSubmachineState { get; set; }

        /// <summary>
        ///     An optional Behavior that is executed whenever this State is exited regardless
        ///     of which Transition was taken out of the State. If defined, exit Behaviors are
        ///     always executed to completion only after all internal and transition Behaviors
        ///     have completed execution.
        /// </summary>
        Behavior exit { get; set; }

        /// <summary>
        ///     An optional Behavior that is executed while being in the State. The execution
        ///     starts when this State is entered, and ceases either by itself when done, or
        ///     when the State is exited, whichever comes first.
        /// </summary>
        Behavior doActivity { get; set; }

        /// <summary>
        ///     The entry and exit Pseudostates of a composite State. These can only be entry
        ///     or exit Pseudostates, and they must have different names. They can only be
        ///     defined for composite States.
        /// </summary>
        IEnumerable<Pseudostate> connectionPoint { get; set; }

        /// <summary>
        ///     An optional Behavior that is executed whenever this State is entered regardless
        ///     of the Transition taken to reach the State. If defined, entry Behaviors are
        ///     always executed to completion prior to any internal Behavior or Transitions
        ///     performed within the State.
        /// </summary>
        Behavior entry { get; set; }

        /// <summary>
        ///     The entry and exit connection points used in conjunction with this (submachine)
        ///     State, i.e., as targets and sources, respectively, in the Region with the
        ///     submachine State. A connection point reference references the corresponding
        ///     definition of a connection point Pseudostate in the StateMachine referenced by
        ///     the submachine State.
        /// </summary>
        IEnumerable<ConnectionPointReference> connection { get; set; }

        /// <summary>
        ///     A list of Triggers that are candidates to be retained by the StateMachine if
        ///     they trigger no Transitions out of the State (not consumed). A deferred Trigger
        ///     is retained until the StateMachine reaches a State configuration where it is no
        ///     longer deferred.
        /// </summary>
        IEnumerable<Trigger> deferrableTrigger { get; set; }

        /// <summary>
        ///     Specifies conditions that are always true when this State is the current State.
        ///     In ProtocolStateMachines state invariants are additional conditions to the
        ///     preconditions of the outgoing Transitions, and to the postcondition of the
        ///     incoming Transitions.
        /// </summary>
        Constraint stateInvariant { get; set; }

        /// <summary>
        ///     The Regions owned directly by the State.
        /// </summary>
        IEnumerable<Region> region { get; set; }

        /// <summary>
        ///     The StateMachine that is to be inserted in place of the (submachine) State.
        /// </summary>
        StateMachine submachine { get; set; }

        /// <summary>
        /// The query containingStateMachine() returns the StateMachine that contains the
        /// State either directly or transitively.
        /// </summary>
        /// <param name="result"></param>
        //StateMachine containingStateMachine(StateMachine result){

        //	return null;
        //}

        /// <summary>
        /// A composite State is a State with at least one Region.
        /// </summary>
        /// <param name="result"></param>
        //void isComposite(result){

        //}

        /// <summary>
        /// The query isConsistentWith specifies that a non-final State can only be
        /// redefined by a non-final State (this is overridden by FinalState to allow a
        /// FinalState to be redefined by a FinalState) and, if the redefined State is a
        /// submachine State, then the redefining State must be a submachine state whose
        /// submachine is a redefinition of the submachine of the redefined State. Note
        /// that consistency requirements for the redefinition of Regions and
        /// connectionPoint Pseudostates within a composite State and connection
        /// ConnectionPoints of a submachine State are specified by the isConsistentWith
        /// and isRedefinitionContextValid operations for Region and Vertex (and its
        /// subclasses, Pseudostate and ConnectionPointReference).
        /// The query isRedefinitionContextValid specifies that the redefinition context of
        /// a redefining Vertex is properly related to the redefinition context of the
        /// redefined Vertex if the owner of the redefining Vertex is a redefinition of the
        /// owner of the redefined Vertex. Note that the owner of a Vertex may be a Region,
        /// a StateMachine (for a connectionPoint Pseudostate), or a State (for a
        /// connectionPoint Pseudostate or a connection ConnectionPointReference), all of
        /// which are RedefinableElements.
        /// </summary>
        /// <param name="result"></param>
        /// <param name="redefiningElement"></param>
        //void isConsistentWith(result, RedefinableElement redefiningElement){

        //}

        /// <summary>
        /// An orthogonal State is a composite state with at least 2 regions.
        /// </summary>
        /// <param name="result"></param>
        //void isOrthogonal(result){

        //}

        /// <summary>
        /// A simple State is a State without any regions.
        /// </summary>
        /// <param name="result"></param>
        //void isSimple(result){

        //}

        /// <summary>
        /// Only submachine State references another StateMachine.
        /// </summary>
        /// <param name="result"></param>
        //void isSubmachineState(result){

        //}
    }
} //end namespace StateMachines